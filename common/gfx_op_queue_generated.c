// This file is automatically generated from gfx_op_queue.scm 

#ifdef OP_ENUMS 
ENUM_GFX_C2V_bitBlt, 
ENUM_GFX_C_DrawCursor, 
ENUM_GFX_P2V_bitBlt, 
ENUM_GFX_P_FilledBox, 
ENUM_GFX_P_Box, 
ENUM_GFX_P_Line, 
ENUM_GFX_P_Point, 
ENUM_GFX_P_Text, 
ENUM_GFX_Line, 
ENUM_GFX_All_Line, 
ENUM_GFX_Box, 
ENUM_GFX_FilledBox, 
ENUM_GFX_Slider_FilledBox, 
ENUM_GFX_All_FilledBox, 
ENUM_GFX_Text, 
ENUM_GFX_P_InvertText, 
ENUM_GFX_P_InvertTextNoText, 
ENUM_GFX_InitDrawCurrentLine, 
ENUM_GFX_InitDrawCurrentLine2, 
ENUM_GFX_DrawCursorPos, 
ENUM_GFX_P_DrawTrackBorderSingle, 
ENUM_GFX_P_DrawTrackBorderDouble, 
ENUM_GFX_V_DrawTrackBorderSingle, 
ENUM_GFX_V_DrawTrackBorderDouble, 
ENUM_GFX_Scroll, 
ENUM_GFX_P_Scroll, 
ENUM_GFX_ScrollDown, 
ENUM_GFX_P_ClearWindow, 
ENUM_GFX_ClearWindow, 
#endif 

#ifdef OP_CASES 
case ENUM_GFX_C2V_bitBlt: QGFX_C2V_bitBlt(window, el->i1, el->i2, el->i3); break; 
case ENUM_GFX_C_DrawCursor: QGFX_C_DrawCursor(window, el->i1, el->i2, el->i3, el->i4, el->i5, el->i6); break; 
case ENUM_GFX_P2V_bitBlt: QGFX_P2V_bitBlt(window, el->i1, el->i2, el->i3, el->i4, el->i5, el->i6); break; 
case ENUM_GFX_P_FilledBox: QGFX_P_FilledBox(window, el->i1, el->i2, el->i3, el->i4, el->i5); break; 
case ENUM_GFX_P_Box: QGFX_P_Box(window, el->i1, el->i2, el->i3, el->i4, el->i5); break; 
case ENUM_GFX_P_Line: QGFX_P_Line(window, el->i1, el->i2, el->i3, el->i4, el->i5); break; 
case ENUM_GFX_P_Point: QGFX_P_Point(window, el->i1, el->i2, el->i3); break; 
case ENUM_GFX_P_Text: QGFX_P_Text(window, el->i1, el->s2, el->i3, el->i4, el->b5); break; 
case ENUM_GFX_Line: QGFX_Line(window, el->i1, el->i2, el->i3, el->i4, el->i5); break; 
case ENUM_GFX_All_Line: QGFX_All_Line(window, el->i1, el->i2, el->i3, el->i4, el->i5); break; 
case ENUM_GFX_Box: QGFX_Box(window, el->i1, el->i2, el->i3, el->i4, el->i5); break; 
case ENUM_GFX_FilledBox: QGFX_FilledBox(window, el->i1, el->i2, el->i3, el->i4, el->i5); break; 
case ENUM_GFX_Slider_FilledBox: QGFX_Slider_FilledBox(window, el->i1, el->i2, el->i3, el->i4, el->i5); break; 
case ENUM_GFX_All_FilledBox: QGFX_All_FilledBox(window, el->i1, el->i2, el->i3, el->i4, el->i5); break; 
case ENUM_GFX_Text: QGFX_Text(window, el->i1, el->s2, el->i3, el->i4, el->b5); break; 
case ENUM_GFX_P_InvertText: QGFX_P_InvertText(window, el->i1, el->s2, el->i3, el->i4, el->b5); break; 
case ENUM_GFX_P_InvertTextNoText: QGFX_P_InvertTextNoText(window, el->i1, el->i2, el->i3, el->i4, el->b5); break; 
case ENUM_GFX_InitDrawCurrentLine: QGFX_InitDrawCurrentLine(window, el->i1, el->i2, el->i3, el->i4); break; 
case ENUM_GFX_InitDrawCurrentLine2: QGFX_InitDrawCurrentLine2(window, el->i1, el->i2, el->i3, el->i4); break; 
case ENUM_GFX_DrawCursorPos: QGFX_DrawCursorPos(window, el->i1, el->i2, el->i3, el->i4, el->i5, el->i6, el->i7, el->i8); break; 
case ENUM_GFX_P_DrawTrackBorderSingle: QGFX_P_DrawTrackBorderSingle(window, el->i1, el->i2, el->i3); break; 
case ENUM_GFX_P_DrawTrackBorderDouble: QGFX_P_DrawTrackBorderDouble(window, el->i1, el->i2, el->i3); break; 
case ENUM_GFX_V_DrawTrackBorderSingle: QGFX_V_DrawTrackBorderSingle(window, el->i1, el->i2, el->i3); break; 
case ENUM_GFX_V_DrawTrackBorderDouble: QGFX_V_DrawTrackBorderDouble(window, el->i1, el->i2, el->i3); break; 
case ENUM_GFX_Scroll: QGFX_Scroll(window, el->i1, el->i2, el->i3, el->i4, el->i5, el->i6); break; 
case ENUM_GFX_P_Scroll: QGFX_P_Scroll(window, el->i1, el->i2, el->i3, el->i4, el->i5, el->i6); break; 
case ENUM_GFX_ScrollDown: QGFX_ScrollDown(window, el->i1, el->i2, el->i3, el->i4, el->i5, el->i6); break; 
case ENUM_GFX_P_ClearWindow: QGFX_P_ClearWindow(window); break; 
case ENUM_GFX_ClearWindow: QGFX_ClearWindow(window); break; 
#endif 

#ifdef OP_FUNCS 


void GFX_C2V_bitBlt(
				    struct Tracker_Windows* window,
				    int from_x1,int from_x2,
				    int to_y
                    ) 
{ 
  queue_element_t *el = get_next_element(window->op_queue); 
  el->type = ENUM_GFX_C2V_bitBlt ; 
  el->i1 = from_x1 ; 
  el->i2 = from_x2 ; 
  el->i3 = to_y ; 
} 




void GFX_C_DrawCursor(
				      struct Tracker_Windows* window,
				      int x1,int x2,int x3,int x4,int height,
				      int y_pixmap
				      ) 
{ 
  queue_element_t *el = get_next_element(window->op_queue); 
  el->type = ENUM_GFX_C_DrawCursor ; 
  el->i1 = x1 ; 
  el->i2 = x2 ; 
  el->i3 = x3 ; 
  el->i4 = x4 ; 
  el->i5 = height ; 
  el->i6 = y_pixmap ; 
} 



void GFX_P2V_bitBlt(
				struct Tracker_Windows* window,
				int from_x,int from_y,
				int to_x,int to_y,
				int width,int height
			) 
{ 
  queue_element_t *el = get_next_element(window->op_queue); 
  el->type = ENUM_GFX_P2V_bitBlt ; 
  el->i1 = from_x ; 
  el->i2 = from_y ; 
  el->i3 = to_x ; 
  el->i4 = to_y ; 
  el->i5 = width ; 
  el->i6 = height ; 
} 



void GFX_P_FilledBox(struct Tracker_Windows* tvisual,int color,int x,int y,int x2,int y2) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_P_FilledBox ; 
  el->i1 = color ; 
  el->i2 = x ; 
  el->i3 = y ; 
  el->i4 = x2 ; 
  el->i5 = y2 ; 
} 



void GFX_P_Box(struct Tracker_Windows* tvisual,int color,int x,int y,int x2,int y2) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_P_Box ; 
  el->i1 = color ; 
  el->i2 = x ; 
  el->i3 = y ; 
  el->i4 = x2 ; 
  el->i5 = y2 ; 
} 




void GFX_P_Line(struct Tracker_Windows* tvisual,int color,int x,int y,int x2,int y2) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_P_Line ; 
  el->i1 = color ; 
  el->i2 = x ; 
  el->i3 = y ; 
  el->i4 = x2 ; 
  el->i5 = y2 ; 
} 


void GFX_P_Point(struct Tracker_Windows* tvisual,int color,int x,int y) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_P_Point ; 
  el->i1 = color ; 
  el->i2 = x ; 
  el->i3 = y ; 
} 



void GFX_P_Text(
	struct Tracker_Windows* tvisual,
	int color,
	char* text,
	int x,
	int y,
	bool clear
	) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_P_Text ; 
  el->i1 = color ; 
  memcpy(el->s2, text, R_MIN(strlen(text)+1,62)); 
  el->i3 = x ; 
  el->i4 = y ; 
  el->b5 = clear ; 
} 



void GFX_Line(struct Tracker_Windows* tvisual,int color,int x,int y,int x2,int y2) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_Line ; 
  el->i1 = color ; 
  el->i2 = x ; 
  el->i3 = y ; 
  el->i4 = x2 ; 
  el->i5 = y2 ; 
} 


void GFX_All_Line(struct Tracker_Windows* tvisual,int color,int x,int y,int x2,int y2) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_All_Line ; 
  el->i1 = color ; 
  el->i2 = x ; 
  el->i3 = y ; 
  el->i4 = x2 ; 
  el->i5 = y2 ; 
} 


void GFX_Box(struct Tracker_Windows* tvisual,int color,int x,int y,int x2,int y2) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_Box ; 
  el->i1 = color ; 
  el->i2 = x ; 
  el->i3 = y ; 
  el->i4 = x2 ; 
  el->i5 = y2 ; 
} 


void GFX_FilledBox(struct Tracker_Windows* tvisual,int color,int x,int y,int x2,int y2) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_FilledBox ; 
  el->i1 = color ; 
  el->i2 = x ; 
  el->i3 = y ; 
  el->i4 = x2 ; 
  el->i5 = y2 ; 
} 


void GFX_Slider_FilledBox(struct Tracker_Windows* tvisual,int color,int x,int y,int x2,int y2) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_Slider_FilledBox ; 
  el->i1 = color ; 
  el->i2 = x ; 
  el->i3 = y ; 
  el->i4 = x2 ; 
  el->i5 = y2 ; 
} 


void GFX_All_FilledBox(struct Tracker_Windows* tvisual,int color,int x,int y,int x2,int y2) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_All_FilledBox ; 
  el->i1 = color ; 
  el->i2 = x ; 
  el->i3 = y ; 
  el->i4 = x2 ; 
  el->i5 = y2 ; 
} 



void GFX_Text(
	struct Tracker_Windows* tvisual,
	int color,
	char* text,
	int x,
	int y,
	bool clear
) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_Text ; 
  el->i1 = color ; 
  memcpy(el->s2, text, R_MIN(strlen(text)+1,62)); 
  el->i3 = x ; 
  el->i4 = y ; 
  el->b5 = clear ; 
} 



void GFX_P_InvertText(
	struct Tracker_Windows* tvisual,
	int color,
	char* text,
	int x,
	int y,
	bool clear
) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_P_InvertText ; 
  el->i1 = color ; 
  memcpy(el->s2, text, R_MIN(strlen(text)+1,62)); 
  el->i3 = x ; 
  el->i4 = y ; 
  el->b5 = clear ; 
} 




void GFX_P_InvertTextNoText(
	struct Tracker_Windows* tvisual,
	int color,
	int len,
	int x,
	int y,
	bool clear
) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_P_InvertTextNoText ; 
  el->i1 = color ; 
  el->i2 = len ; 
  el->i3 = x ; 
  el->i4 = y ; 
  el->b5 = clear ; 
} 



void GFX_InitDrawCurrentLine(
	struct Tracker_Windows* tvisual,
	int x, int y, int x2, int y2
) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_InitDrawCurrentLine ; 
  el->i1 = x ; 
  el->i2 = y ; 
  el->i3 = x2 ; 
  el->i4 = y2 ; 
} 


void GFX_InitDrawCurrentLine2(
	struct Tracker_Windows* tvisual,
	int x, int y, int x2, int y2
) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_InitDrawCurrentLine2 ; 
  el->i1 = x ; 
  el->i2 = y ; 
  el->i3 = x2 ; 
  el->i4 = y2 ; 
} 



void GFX_DrawCursorPos(
	struct Tracker_Windows* tvisual,
	int fx, int fy, int fx2, int fy2,
	int x, int y, int x2, int y2
) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_DrawCursorPos ; 
  el->i1 = fx ; 
  el->i2 = fy ; 
  el->i3 = fx2 ; 
  el->i4 = fy2 ; 
  el->i5 = x ; 
  el->i6 = y ; 
  el->i7 = x2 ; 
  el->i8 = y2 ; 
} 



void GFX_P_DrawTrackBorderSingle(
	struct Tracker_Windows* tvisual,
	int x, int y, int y2
) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_P_DrawTrackBorderSingle ; 
  el->i1 = x ; 
  el->i2 = y ; 
  el->i3 = y2 ; 
} 



void GFX_P_DrawTrackBorderDouble(
	struct Tracker_Windows* tvisual,
	int x, int y, int y2
) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_P_DrawTrackBorderDouble ; 
  el->i1 = x ; 
  el->i2 = y ; 
  el->i3 = y2 ; 
} 



void GFX_V_DrawTrackBorderSingle(
	struct Tracker_Windows* tvisual,
	int x, int y, int y2
) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_V_DrawTrackBorderSingle ; 
  el->i1 = x ; 
  el->i2 = y ; 
  el->i3 = y2 ; 
} 



void GFX_V_DrawTrackBorderDouble(
	struct Tracker_Windows* tvisual,
	int x, int y, int y2
) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_V_DrawTrackBorderDouble ; 
  el->i1 = x ; 
  el->i2 = y ; 
  el->i3 = y2 ; 
} 



void GFX_Scroll(
	struct Tracker_Windows* tvisual,
	int dx,int dy,
	int x,int y,
	int x2,int y2
) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_Scroll ; 
  el->i1 = dx ; 
  el->i2 = dy ; 
  el->i3 = x ; 
  el->i4 = y ; 
  el->i5 = x2 ; 
  el->i6 = y2 ; 
} 



void GFX_P_Scroll(
	struct Tracker_Windows* tvisual,
	int dx,int dy,
	int x,int y,
	int x2,int y2
	) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_P_Scroll ; 
  el->i1 = dx ; 
  el->i2 = dy ; 
  el->i3 = x ; 
  el->i4 = y ; 
  el->i5 = x2 ; 
  el->i6 = y2 ; 
} 



void GFX_ScrollDown(
	struct Tracker_Windows* tvisual,
	int dx,int dy,
	int x,int y,
	int x2,int y2
) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_ScrollDown ; 
  el->i1 = dx ; 
  el->i2 = dy ; 
  el->i3 = x ; 
  el->i4 = y ; 
  el->i5 = x2 ; 
  el->i6 = y2 ; 
} 



void GFX_P_ClearWindow(struct Tracker_Windows* tvisual) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_P_ClearWindow ; 
} 



void GFX_ClearWindow(struct Tracker_Windows* tvisual) 
{ 
  queue_element_t *el = get_next_element(tvisual->op_queue); 
  el->type = ENUM_GFX_ClearWindow ; 
} 

#endif 
